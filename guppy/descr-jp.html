<!--This file created 03.4.15 7:13 PM by Claris Home Page version 2.0J-->
<HTML lang="ja">
<HEAD>
   <TITLE>docments</TITLE>
   <META NAME=GENERATOR CONTENT="Claris Home Page 2.0J">
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html">
   <X-SAS-WINDOW TOP=62 BOTTOM=1020 LEFT=34 RIGHT=564>
   <X-SAS-REMOTESAVE SERVER="staff.aist.go.jp" USER="y21650"
   DIR="guppy/" FILE="">
</HEAD>
<BODY>
		<div align="left">
			<h3>遺伝子配列表示プログラムGuppy</h3>
			<p>ドラフト0.8　上野　2003/Aug/22</p>
			<p></p>
			<p>Guppyは遺伝子配列データをグラフィカルに表示するプログラムである。配列中にあるタンパク質に翻訳される領域や、マーカとして知られている部位などのアノーテーションを遺伝子上の位置にレイアウトしたシークエンスマップを作成し、メニューまたはスクリプトによって編集することができる。アノーテーションデータは、一般に利用されている各種フォーマットに対応しており、Guppy独自のフォーマットに保存することで高速な処理を実現している。</p>
			<p></p>
			<h4>１．プログラムの基本動作</h4>
			<p>プログラムGuppyは、スクリプトファイルに指定された画面のレイアウトを表示する。スクリプトファイルでは、他に読み込むデータファイルを指定することもでき、複数のデータファイルの扱い方や、加工処理もできるようになっている。</p>
			<p>　最も簡単なguppyのスクリプトファイルsimple.gpyでは、中に遺伝子の注釈データも含まれていていて、スクリプトファイルだけを使って画面が表示される。Fileメニューのsaveを選択すると、作図した画面を再現するスクリプトファイルが保存される。</p>
			<p>　guppyで表示できるファイルはguppyスクリプトファイルのほか、GenBank、GFFフォーマットのファイルを直接指定することもできるいようになっている。与えられたファイルは自動的にguppyのファイルに変換され、標準的なレイアウトで表示される。</p>
			<blockquote>
				<pre>% guppy filename</pre>
			</blockquote>
			<p>スクリプトファイルを指定する場合は、与えるパラメータをファイル名に続けて指定すると、それらはスクリプトファイルによって処理される。</p>
			<blockquote>
				<pre>% guppy scriptfile datafile ...</pre>
			</blockquote>
			<p></p>
			<p>genbankおよび、GFFのフォーマット（genedecoder結果等）のファイルは、guppyの組込みのスクリプトgenbank.gpy、 gffv1.gpyによって処理される。コマンドラインに指定するとファイルフォーマットを自動判別してそれぞれの組込みスクリプトファイルが呼ばれるようになっている。gffファイルの場合、２つ目にfasta形式のシークエンスファイルを指定することができる。レイアウトには組込みのスクリプトが使われているが、これらを修正することによって、必要なアノーテーションを表示するように変更することもできる。</p>
			<blockquote>
				<pre>% guppy gff-file fasta-file</pre>
			</blockquote>
			<p></p>
			<h4>２．プログラムの構成</h4>
			<p>GuppyはＣ言語で作成された通常のプログラムであるが、プログラムとデータ構造を柔軟に拡張したり修正するため、Lua言語処理系を組み込んでいる。Lua言語はＣ言語で実装さているフリーウェアである。guppyプログラムの表示するシークエンスマップは、Lua言語の文法に沿ったスクリプトファイルに記述され、これを読み込んで画面に表示する（図参照）。Lua言語処理系の持つデータはメモリ上で簡易データベースの機能を利用できるので、ここではメモリデータベスと呼ぶ。Lua言語パーサによって読み込まれたアノーテーションデータは、Guppyのグラフィック表示モジュールで実際に描画される。表示する図形の種類やラベルにつける文字や、場所や大きさの指定は、Guppyシークエンスマップファイルに記されている。これもLua言語の文法で従っているので、Lua言語パーサによって、レイアウトを指定するスクリプトとして読み込まれ、その記述に従ってレイアウトされる。</p>
			<p><img src="../gpyf2.gif" width=504 height=420 X-SAS-UseImageWidth X-SAS-UseImageHeight align=bottom></p>
			<p>通常の遺伝子配列情報データは様々なフォーマットで配布されているため、guppyでは、ファイル変換機能を持ち、既存のいくつかのフォーマットのデータをguppyで読める形式に変換して表示する。アノーテーションデータはguppyの標準形式（カタログフォーマット）に変換し、注目するデータを選択して表示する。また、Guppyでは、シークエンスマップの編集のために、guppyシークエンスマップファイルに書くことのできるコマンドが用意されており、それらのうちいくつかはGUI操作によっても行うことができる。</p>
			<h4>３．Guppy ファイル</h4>
			<p>Guppyでは、配列データのアノーテーションを素直に表現するために階層構造データを記述するだけでなく、変数や関数を用いてそれらのデータを扱う処理プログラムを書けるようになっている。これらのデータ記述とプログラミング機能には、Lua言語処理系を採用している。特にLua言語のテーブル型データが頻繁に利用されており、以下では単にテーブルと呼ぶ。guppyのテストデータである simple.gpy は、典型的なguppyファイルの例である。</p>
			<p></p>
			<h4>（１）カタログ形式データ</h4>
			<p>guppyで表示するアノーテーションデータの基本形は、カタログ形式と呼ぶ次のようなaフォーマットのasciiファイルである。</p>
			<p></p>
			<dl>
				<dd>one=mbCatalog{
				<dl>
					<dd>{symbol=&quot;orfD&quot;,pos1=18,pos2=28, category=1},
					<dd>{symbol=&quot;orfE&quot;,pos1=38,pos2=58, category=1},
					<dd>{symbol=&quot;orfF&quot;,pos1=78,pos2=238, category=3;
					<dl>
						<dd>{symbol=&quot;5'utr&quot;,pos1=78,pos2=84},
						<dd>{symbol=&quot;exon&quot;,pos1=85,pos2=133},
						<dd>{symbol=&quot;exon&quot;,pos1=185,pos2=220},
					</dl>
					<dd>}
				</dl>
				<dd>}
				<dd>
			</dl>
			<p>ここでは、領域を示すpos1,pos2の数値データと名前symbolの各項目が指定され、{}でくくられたアノーテーションが記述されている。個々のアノーテーションは、データベースのエントリのように、複数のデータで構成されるレコードであり、各項目値をフィールドと呼ぶ。それぞれのレコードは、シークエンスマップ上に、後に指定する形と色で表示される。上の例では、３番目のアノーテーションはさらにその内部の詳細情報としてのレコードが入れ子で入っている。これは別の手続で表示される。Lua言語においては、このように、各項目の名前と値のペアの組を大カッコ｛｝でくくったものがテーブルであり、そのようなテーブルの配列がカタログ形式である。</p>
			<p>　　アノーテーションの各レコードには、pos1,pos2,symbolの3つのフィールドが必ず必要である。その他の性値として、上記の例ではcategoryが指定されている。データの形式は数値と文字列であり、必要に応じて自由に新しい属性値を追加することができる。ただし、pen, fill, label, shape は、表示属性として使われる。アンダースコアから始まるフィールド名はシステムが使用する。先頭にあるmbCatalogというのは、カタログであることを宣言するために使われる。</p>
			<p>　　作成したデータは、次に述べるguppyのスクリプト(プログラム)で変数で参照することができる。ここではoneという変数でデータ構造化全体を参照している。2番目のテーブルにあるアノーテーションを参照するには、one[2]と書き、その属性を参照するには、one[2].symbolのようにドットで指定することができる。このように、アノーテーションを示すテーブルはカタログ中の絶対番号によってユニークに参照される。しかし、通常はそのテーブルを表示するときには属性値のsymbolを使うのが便利である。したがってsymbolの名前の重複は可能であるが、ユニークな名前を利用するのが望ましい。</p>
			<h4>４．スクリプト</h4>
			<p>　　シークエンスマップは、guppyに対するコマンドで作成される。基本的なコマンドはaddlaneであり、配列に沿った表示領域のレーンを作り、そこにカタログ中の注釈を図形にして表示する。作成した図形は、このレーンごとにグループ化されて名前を付けられる。図形要素を追加するには、グループとその要素の番号を指定するが、通常はカタログにおける配列のインデックス値が使われる。カタログ中の注釈をすべて図形要素にするには、次のような文で行う。</p>
			<blockquote>
				<pre>expm:addlane(&quot;pic&quot;,{source=catalog,...})</pre>
			</blockquote>
			<p>通常は複数のaddlaneコマンドによってシークエンスマップが作成され、その命令を列挙したファイルがスクリプトファイルである。このスクリプトはLua言語のプログラムであって、命令文には、代入文、関数呼び出し、guppyコマンド呼び出し、がある。代入文はa=2のようなもの、関数呼び出しは、print(&quot;hello&quot;)というものである。addlaneはguppyコマンド呼び出しで、対象名とコロンを関数の前につける形になる。対象名は、guppyの作業名であり、ここではexpmという名前がつけられている。このguppyコマンドのパラメータでは、{ height=10, shift=0 } のようにカンマで区切った属性値として指定する。height は、縦方向の領域の大きさ、shiftは縦の位置シフトである。さらに、表示する図形の形状、色、も指定することができる。</p>
			<dl>
				<dd>shape=&quot;GPYbox&quot;　　または、GPYthinbox, GPYarrow, GPYmark, GPYscale, GPYplot
				<dd>pen=#色番号
				<dd>fill=#塗りつぶし
				<dd>fy=#縦の位置シフト
				<dd>sx=#文字列の位置シフト
				<dd>sy=#文字列の位置シフト(シークエンス座標値)
				<dd>lavel=&quot;stringdata&quot;
				<dd>
			</dl>
			<p>これらの表示パラメータはこの表示グループの通常の値であり、もし個々のデータの中に属性値が記述されていればそれが優先される。通常は、アノーテーションとして表示される文字列にはカタログの個々のデータのもつsymbolの値が利用されるが、labelによって表示する文字列を指定できる。addlaneのパラメータにlabelが指定されているとすべてのアノーテーションに同じラベルが付けられる。また、addlaneのパラメータとしてだけ使えるパラメータにfontwidthを指定できる。</p>
			<p></p>
			<p>図形要素のGPYplotを使って数値データをプロットする時には、下記のような配列データを利用する。laneのパラメータwaveに指定する。scaleとbiasによってグラフの大きさと位置を調整できる。</p>
			<blockquote>
				<pre>mywave= { 10, 10, 20, 20, ...... ; step= 100 }</pre>
			</blockquote>
			<p>step がないときはstep=1000がデフォルトである。その他に、通常は下記のようなコマンドが使われている。</p>
			<dl>
				<dd>expm=guppy:new()　　　新しいguppy作業を作成する。
				<dd>expm:addcatalog{}　　　カタログの登録
				<dd>expm:addsequence{}　　シーケンスデータの登録
				<dd>expm:layout{}　　　　　グラフィックスレイアウトのパラメータの指定。
			</dl>
			<p>Guppyのスクリプトは、Lua言語インタプリタで処理されるので、Guppy固有の関数の他にLuaの標準関数が利用できる。</p>
			<p>コマンドはおおむね次のような一般形式である。parameter は２つ以上のときは、テーブルを使う。</p>
			<dl>
				<dd>expm:operation([target,] parameter)
				<dd>　　　コマンド名　対象　パラメータ
				<dd>
				<dd>new 新しい名前 なし
				<dd>名前は未サポート
				<dd>addcatalog 新しいカタログの名前 カタログ
				<dd>addsequence 新しいシークエンスの名前 テーブル
				<dd>layout レイアウトの名前 left,top,dps（計画）
				<dd>
				<dd>addlane 新しい表示グループ名 source,selection,
				<dd>title
				<dd>pen,label,fontsize,
				<dd>parent,fold,
				<dd>defaultview
				<dd>open ファイル名
				<dd>save ファイル名 なし
				<dd>import ファイル名 なし
				<dd>
				<dd>movelane 表示グループ名 上下移動数
				<dd>modlane 表示グループ名
				<dd>renamelane n/a
				<dd>deletelane n/a
				<dd>deleteprim 表示グループ名 表示図形id番号（カタログ中のテーブル番号）
				<dd>addprim 表示グループ名 id, pen,fill,shape,fy,pos1,pos2,label,sx,sy
				<dd>modprim 表示グループ名 id, pen,fill,shape,fy,pos1,pos2,label,sx,sy
				<dd>
			</dl>
			<h4>５．guppyプログラムファイル</h4>
			<p>プログラムファイルとは、スクリプトファイルと同様にguppyによって読み込まれて実行されるが、script()関数において、guppyの画面レイアウトを定義しないものである。後で利用可能な関数の定義をしてguppyの機能を拡張するのに使う。プログラムファイルを使うとで、スクリプトファイルの一部を変更して実行させるなど、guppyの機能を拡張するための柔軟な対応ができる。スクリプトファイルは型式的にはプログラムの一種であり、script()関数があるものをスクリプトファイルと呼ぶ。通常はここにguppyのレイアウト定義が含まれているが、ファイル変換のスクリプトは、レイアウトを定義しないで、ファイル変換だけを行うようになっている。</p>
			<p>プログラムファイルは、通常起動時にコマンドラインに指定してロードする。ファイルがロードされた後、script()関数は現在有効なものが一つだけ呼ばれる。したがって、典型的な使い方をscript()関数として記述することで、スクリプトファイルとして利用できるようになる。たとえば、ファイル変換プログラムはguppyプログラムファイルであるが、もしファイル変換プログラムだけを指定してguppyを起動すると、そのscript()関数が実行され、標準入出力を使ったファイル変換をするスクリプトとなる。</p>
			<p>guppy:new()コマンドを使ってシークエンスマップを作成しなかった場合は、グラフィックスを使用しないデータ処理プログラムとして動作する。すなわち、コマンドラインから動作させる形で、すでにguppyに組込まれているファイル変換プログラムを単独で動作させることができる。また、このグラフィックスを使わない処理は、mbluaというプログラムに分離されているので、luaインタプリタだけを用いて実行させるmbluaコマンドをguppyのソースから得ることもできる（ファイル名mblua1.lua）。guppyスクリプト、プログラムファイルは、ファイルの先頭100行のうちに、moonscript(&quot;guppy&quot;)　という行があることで判別される。</p>
			<p>guppyの保存機能によって作成したものもスクリプトファイルである。プログラムファイルは、通常は関数を与えるために用いる事が多い。guppy スクリプトファイルがパラメータを必要とする場合には、script() 関数の引数としてパラメータを得ることができる。</p>
			<p></p>
			<p>guppy の起動時に使われるプログラムとスクリプトの関係</p>
			<p>コマンドライン　% guppy script1 script2 p1 p2</p>
	
			<pre>init.gpy mblua  script1, script2
-----------------------------------
guppy	----&gt;
    load gpy*.lua
    load mblua1.lua
     |
		   |
		   +---&gt;	main()
				       |  arg={script1,script2,p1,p2}
				       |
     			     	load script1
				       |　
		      		    load script2
				       |
		    		   +------&gt;	　
		     	        			| script(p1,p2)  関数呼び出し
		    		   +&lt;------
			    	   |
		   +&lt;----	
		   |
	&lt;----
</pre>
			<p>　　　　複数のscript ファイルにscript()関数の定義が複数ある時は、後が有効になる。guppyの起動時には、init.gpyが実行され、mblua1.luaを実行する。この２つの起動時スクリプトの他にあらかじめいくつかのスクリプトがguppyには内蔵されている。それらはリソースファイルとしてguppyの実行ファイルに結合されており、doresfile()関数によってLuaインタプリタで処理される。したがって、これを呼び出すには、新たなスクリプト関数が必要である。</p>
			<p>　リソースファイルはunixでは一般には定義されていないので、ashleyライブラリのpaxフォーマットという形式を利用している。詳細は文献（Y.Ueno, M.Arita &amp; K. Asai, Genome Informatics 2000）あるいは配布パッケージ中のpaxy.txtとリソースを作成するプログラムpaxyが参考となる。</p>
			
			<h4>６．コンパイル</h4>
			<p>　　guppyはソースコードで配布されているので、コンパイルして実行型式ファイルを作成する。典型的なunix環境ではmakeで作成できるようになっている。手順は下記のとおりである。</p>
			<p>（１）ソースコードを展開する。</p>
			<pre>% tar xzf gpy0999.tgz</pre>
			<pre>あるいは、% gunzip &lt; gpy0999.tgz | tar xf -</pre>
			<p>（２）makeする</p>
			<pre>% cd bistro/ddguppy</pre>
			<pre>% make</pre>
			<p>標準的な環境（Linux, SunOS, IRIX, HP-UX, FreeBSD, DigitalUNIX ) では、unameコマンドによって既成のmakedefをコピーしてmakeするようになっている。makeに失敗する場合は、makefileの問題とソースコードの問題に別れる。まず、コンパイラのエラーメッセージから、ソースコードの修正で対応できるか調べる。</p>
			<p>もしコンパイラのオプションやパスが間違っている場合は、makedefファイルの変更が必要である。bistro/ddashleyにてmakeできるようにmakedefを編集し、成功したら　bistro/ddguppy にも同じmakedefをおく。</p>
			<p></p>
			<p>（３）makeupディレクトリに実行ファイルをコピーする</p>
			<pre>% cd makeup</pre>
			<pre>% cp guppy ~/work （作業ディレクトリ）</pre>
			<p></p>
			<p>変更点等はreadme.txtを参照して作成する。windowsやmacosにも移植されているので、詳細はguppyホームページの最新情報を参照していただきたい。</p>
			<p></p>
			<h4>７．謝辞</h4>
			<p>このプログラムguppyの開発は、多くの方の多大な協力によって実現したものであった。ここに感謝の意を表したい。電子技術総合研究所においては、浅井潔博士、有田正則博士、佐藤主税博士、秋山泰博士、諏訪牧子博士、大津紀之部長、北陸先端大学の小長谷明彦教授、高橋勝利博士、金大心博士、産業技術総合研究所に組織変更したのち、水野政彦博士、また、プログラムおよびデータ作成にあたっては、株式会社富士総合研究所の大河内郁夫様、インテック株式会社の小森様、日鉄日立システムエンジニアリング株式会社の高本久様、明尾誠様、大隈伸昌様、佐々木淳様、横山幸恵様の協力を得ることができた。また、奈良先端大学の森浩禎教授、荒武博士、大島拓博士、佐藤哲大博士、には多くの貴重な助言をいただき、有用なデータを提示していただいた。皆様方の御協力に重ねて感謝申し上げる。</p>
			<hr>
		</div>
	</BODY>
</HTML>
