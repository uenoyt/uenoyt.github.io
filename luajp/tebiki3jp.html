<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!--This file created 午後 02:42  03/09/05 (金) by Claris Home Page version 2.0J-->
<HTML>
<HEAD>
   <TITLE>lua intro</TITLE>
   <META NAME=GENERATOR CONTENT="Claris Home Page 2.0J">
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html">
   <X-SAS-WINDOW TOP=0 BOTTOM=631 LEFT=0 RIGHT=987>
<meta http-equiv="content-type" content="text/html; charset=Shift_JIS">
</HEAD>
<BODY>

<hr>
　＝＝　この文書はLuaバージョン４の内容です　＝＝
<hr>


<H3>Lua言語の手引き</H3>

<H4>― プログラミング言語Lua(4.0)についての基礎知識</H4>

<P>TeCGraf, PUC-Rio</P>

<P>訳2001年10月24日</P>

<H4>1. はじめに</H4>

<P>この文章は、フリーソフトウエアLuaのホームページから配布されているポルトガル語で書かれたLuaの入門書の和訳です。Waldemar
Celes Son、 Luiz Enrique de Figueiredo、 Robert Ierusalimschy
によって書かれた論文"Programming in Lua - Practical Theory (version
2.1) " および "The Language of Extension Lua "の内容を含んでおり、Lua
version 3.1 への対応は Anna Magdalena Hester による文 書をもとに
Robert de Beauclair Seixas
によって行われました。日本語への翻訳は、原著者の許可を得て、大阪大学大学院の池田　徹志さんと、産業技術総合研究所　阿部　幸絵さんの協力のもとに、産業技術総合研究所　上野　豊　によって行われました。
</P>

<PRE>     ftp://ftp.tecgraf.puc-rio.br/pub/lua/nocoes-3.1.pdf 
     http://www.tecgraf.puc-rio.br/lua/ftp/nocoes-3.1.pdf</PRE>

<P>Luaはフリーソフトウエアとして配布されているプログラミング言語ですが、
TeCGrafが著作権を保持しています。</P>

<PRE>     ftp://ftp.tecgraf.puc-rio.br/pub/lua/lua-3.1.tar.gz 
     http://www.tecgraf.puc-rio.br/lua/</PRE>

<P>Copyright (c) 1994-1998 TeCGraf, PUC-Rio. Written by Waldemar
Celes Filho, Roberto Ierusalimschy, Luiz Henrique de Figueiredo. All
rights reserved.</P>

<H4>2. 概要</H4>

<P>Lua言語は、C
言語などで書かれたアプリケーションプログラムに組み込んで、初期設定や機能拡張を実現するために開発されたプログラミング言語です。アプリケーションプログラムに、Lua言語の処理系を組み込むことで、パラメータ設定やカスタマイズした処理をLua言語で記述することができます。また、単独で動作するLua言語インタプリタを使って、目的の処理を行うプログラ
ムを作成することもできます。
Lua言語は、いわゆる関数型のプログラム言語で、処理の流れは、Pascal言語に似た簡素な文法になっています（if-elseif-else-end,
while-do-end,
repeat-until）。そして、データ記述方法が豊富で、便利な機能があります。
（１）文字列データの 処理を容易にするパターンマッチング
（２）テーブル型デー タによる構造化したデータの記述
（３）テーブル内容の動的な変更が可能
（４）自動メモリ割り当てとガベージコレクション メ
モリの再配置や初期化などは言語処理系の持つガーベジコレクション機能によっ
て、メモリや変数の定義などに煩わされることなく、多様に構造化したデータを扱うプログラミングができます。テーブル型データは、データを抽象化するのに便利です。Lua言語のプログラミングでは標準関
数やその他のライブラリ関数が利用できますが、独自の関数を追加することもできます。
これまでにLua言語を使ったシステムもいくつか開発されています。例えばCGILua
は、高度なWebサイトを構築できるシステムですが、Lua言語によるスクリプトを使って、動的なHTML文書を生成できるようになっています。
</P>

<PRE>     http://www.lua.org</PRE>

<H4>3. プログラムと実行環境</H4>

<P>Lua言語のプログラムは、命令文と関数の定義で構成されます。それらは一つの実行環境の中に作成されます。命令文はテキスト中のどのカラムにあってもよく、フリーな書式で、スペースや改行で区切ったり、セミコロン
( ;)
で明示的に区切ったりすることもできます。また、２つの連続したハイフン
( -) から行末までがコメントとなります。
Lua言語のインタプリタは、一つの実行環境に複数のプログラムを読み込むことができ、それぞれのプログラムは、読み込まれた順に翻訳され、それぞれの命令文が実行されます。そして、関数定義の中にある命令文は翻訳されたあと、関数のコードとして登録されます。また、大域変数や関数の登録されている実行環境は、インタプリタを動作させたときに作られ、利用を終了するまで有効で、それらの関数やデータは、Lua言語のプログラムやC
言語とのインターフェイ スのライブラリで、操作できます。
Lua言語の処理系では、実行単位のプログラムをチャンクと呼びますが、それを仮想マシンの実行コードに翻訳し、その後仮想マシンによってコードを実行します。登録されている関数のコードは、関数が呼び出された時に高速に実行されます。これは、コンパイラとインタプリタを融合した方式で、プログラムを逐次翻訳することで実行速度を低下させることなく、イン
タプリタの使いやすい環境を保っています。</P>

<H4>4. 変数と型</H4>

<P>Luaのプログラムでは、大域変数は宣言なしで使うことができます。（注：後で説明する局所変数を使うこともできます）例えば、次の文で、新たに変数
a を使い、2.3という数値型のデータを参照するようにします。</P>

<PRE>     a =  2.3</PRE>

<P>そして次の例では変数aで文字列データを参照するように変更します。
</P>

<PRE>     a = "Language Lua"</PRE>

<P>Lua言語では、変数には型がありませんが、変数で参照するデータの種類には型があり、
nil, 数値, 文字列, 関数, C の関数, ユーザデータ、
テーブルの７種類あります。</P>

<H5><I>nil</I> 型</H5>

<P>nil型は 未定義データを表します。</P>

<PRE>     a = b</PRE>

<P>この場合は、変数 b の参照するデータは nil となるので、変数 a には
nil が代入されます。次の例のように、 nil
という予約語で表現することができます。</P>

<PRE>     a = nil</PRE>

<P>変数 a には nil という値が代入されますが、 a に値が入っ
ていない状態と同じです。変数に値が入っていないかどうかは次のようにテストすることができます。したがって、すべての未定義の変数は
nil と いう値を持つと考えられます。</P>

<PRE>     a == nil</PRE>

<H5><I>数値</I>型</H5>

<P>Lua で扱う数値データは実数と整数の区別はありません。次の例では、
a、 b、 c、d の各変数に数値を代入しています。</P>

<PRE>     a =4
     b =4.0 
　   c =0.4e1 
     d =40e-1</PRE>

<H5><I>文字列</I>型</H5>

<P>Lua の文字列は一重引用符(' ')または二重引用符("
")で囲まれる文字の系列
です。文字列中では、以下のエスケープシーケンスを用いることができます。
</P>

<PRE>     \n     <I>改行 
　</I>   \t     <I>水平タブ 
　</I>   \r     <I>復帰 
　</I>   \v     <I>垂直タブ </I>
     \xxx   <I>文字コードが 10 進数 xxx  の文字 
　</I>   \a     <I>ベル 
　</I>   \b     <I>一文字後退 
　</I>   \f     <I>フォームフィード </I>
     \\    <I> バックスラッシュ 
　</I>   \"     <I>二重引用符  (") 
　</I>   \'     <I>一重引用符  (') 
　</I>   \\     <I>バックスラッシュ(\)</I></PRE>

<P>二重引用符で囲まれた文字列中では、一重引用符をエスケープ無
しでそのまま用いることができます。しかし、ある文字列を囲むのに用いられている引用符合をその文字列中で用いるときには、エスケープする必要があり
ます。次の二つは文字列として有効であり、同一の文字列です。</P>

<PRE>     s = "Olho  d'agua" 
     s = 'Olho  d\'agua'</PRE>

<P>二重の角括弧も文字列を囲むのに用いられます。二重引用符や一重引用符と異なり、この中ではエスケープシーケンスが解釈されません。また内部に入れ子の文字列を含むこともできます。
</P>

<P>例:</P>

<PRE>     s = [[This is a text
     that crosses
     a string more than and contains one 
     string nested:  [[nested]] in the end!]]</PRE>

<H5><I>関数</I></H5>

<P>Lua
の関数はファーストクラスの型です。つまり、関数は変数に代入したり、他の関数へ引数として渡したり、戻り値として返したりすることができます。関数の定義は大域変数に値を代入することと同じで、関数の持つプログラムが値になります(6参照)。代入された大域変数は関数型の値を持ちます。関数定義は次のようになりますが、ここで、変数
func1に関数型の値が代入されることになります。</P>

<PRE>     function func1  (...) 
　      ... 
     end
　
これは次のような関数呼び出しを行うことで実行できます。
　
     func1(...)</PRE>

<H5><I>ユーザデータ</I></H5>

<P>ユーザデータ型を用いることで、 C 言語の変数を Lua
の変数に代入できます。 ユーザデータ型は C 言語の void * 型に相当し、C
言語の変数を Lua
の変数で扱うことができます。代入と等価性の判定以外の演算以外は行うことができませんが、
Lua言語 と C を結合するプログ ラムを書くのに便利です。しかし、Lua
言語のみでプログラムを書く時には用いるこ とはできませんし、Lua言語
中でこの型の値を直接生成することもできません。</P>

<H5><I>テーブル</I></H5>

<P>テーブル型は Lua
における主要な型です。テーブル型は連想配列を実現して おり、nil
以外の他の任意の型のインデクスを用いることができます。
テーブル型を用いることで、ベクトル、リスト、レコード等の型を同一の構造で作成できます。テーブル生成の構文を説明する前に１つ例を示します。以下は空のテーブルを明示的に作成して
a に代入します。</P>

<PRE>     a = {  }</PRE>

<P>このテーブルに後からフィールドを追加することも可能です。
テーブルに関しては7節で詳述します。</P>

<H4>5. 代入と演算</H4>

<P>前述のように Lua
の変数は型を持たず、変数はいろいろな型の値を保持します。Lua
の変数は動的に型づけされ、値が変数に代入される時に特定の１つの型を持ちます。同じ変数に別の値が代入されれば、変数は２
度目に代入された値を持ちます。したがって２度目の代入の前には、その変数はある１つの型を持っていますが、代入の後には別の型の値を持っ
ていることがあります。変数が持つ値に演算を行うとき、その値が行う演算に有効なものであるかどうかは実行時にチェックされます。例えば関数を値とし
て持つ変数に加算を行おうとした場合には、実行時エラーになります(脚注２)。
</P>

<H5>－通常の代入と多重代入－</H5>

<P>前節では簡単な代入の例を示しました。Lua では多重代入も可能で、
１回の代入で２つの異なる代入操作をすることができます。</P>

<PRE>     s, v =  "Language Lua", 2</PRE>

<P>この例は "Language Lua" という文字列を変数 s に代入し、 2
という数値を変数 vに代入します。
また、左辺の変数の数が右辺の値の数と異なることもあります。その場合には
左辺の変数に nil が入れられるか、右辺の値が捨てられます。</P>

<PRE>     a, b = 2 
     c, d = 2, 4, 6</PRE>

<P>この例では a に 2、 b に nil が代入されます。 また c には 2、 d
には 4 が代入され、6
という値は捨てられます。多重代入を利用することで、変数の値の交換を１つの命令で書くことがで
きます。</P>

<PRE>     a,  b = b, a</PRE>

<P>この例では a が持っていた値が b に、 b が持っていた値 が a
に代入されます。よって、一時的な変数を用意する必要はありません。
(脚注２: この振舞いはタグ関数を用いることで変えることができる。 Lua
参照マニュアルを参照。)</P>

<H5>－演算子－</H5>

<P>Lua言語には、算術演算子、関係演算子、論理演算子、文字列を連結する演算子があり、ま演算が行われるときに、できるだけ自動的に型変換されます。
</P>

<H5>○算術演算</H5>

<P>Lua には一般の算術演算子があります。２項演算子には + (加算)、 -
(減算)、 *(積算)、 / (除算) があります。また符合反転の - があります。
演算順序を変えるため、括弧を使うことができます。
以下は正しい式の例です。</P>

<PRE>     a = 2 *  3.4 
     b = (a + 1) / 3.4 
     c = 2 *  (-3)　　</PRE>

<P>算術演算子は数値型の値にのみ使用できます(数値型に変換可能な文字列に対しても可能です。"自動的な変換"
の節を参照)。演算子 ^ は通常は巾乗で、Lua
言語の数学関数ライブラリが使われます。この２項演算子 ^
は高い優先順位で処理されますが、内部的には、タグ関数を使って実装されています(Lua
参照マニュアル参照)。</P>

<H5>○関係演算子</H5>

<P>Lua には以下の関係演算子があります。</P>

<PRE>             &lt;      <I> 小さい </I>
             &gt;      <I> 大きい </I>
             &lt;=     <I> 小さいか等しい </I>
             &gt;=     <I> 大きいか等しい </I>
             ==     <I> 等しい </I>
             ~=     <I> 異なる</I></PRE>

<P>関係演算子は、結果が偽の時 nil を返し、真の時 1 を返します。</P>

<PRE>     a = 4 &lt; 3 
     b = 4 &gt; 3   </PRE>

<P>この例では a に nil が代入され、 b に 1 が代入されま す。演算子
&gt;,&lt;,&gt;=,&lt;=
は<I>数値</I>型または<I>文字列</I>型の値で使用でき、真偽の判断を行います。
そして、それは<I>タグ関数</I>を使うことで変更できます (Lua
参照マニュアルを参照)。 等価演算子 (==)
は、はじめに比較される値の型が等しいかを調べ、 異なる場合には nil
を返します。型が同じ場合には、値が等しいか を調べます。
数値や文字列の等しさは通常の基準で判断されます。テーブル、関数、ユーザデータは参照が比較されます。
例えば２つのテーブルの場合、その２つのテーブルが同一の対象であるかどうかで判断されるので、同じ要素を持っているかどうかでは判断されません。
非等価演算子 (~=) は等価演算子の逆です。</P>

<H5>○論理演算子</H5>

<P>論理演算子は”かつ”、”または”、”でない”の３つです。</P>

<PRE>         and    <I> かつ </I>
         or     <I> または </I>
         not    <I> でない   </I></PRE>

<P>and や or
が複数ある場合には、左から右に評価されるので、全ての演算が評価される前に、式の値が決まってしまうことがあります。
</P>

<PRE>     a = 23 
     b = 15 
     c = a &lt; 20  or  b &gt; a 
     d = a &lt; 20 and  b &gt; a   </PRE>

<P>この例では、 c と d は nil になります。 d の場合、まず a&lt;20
が偽となり、論理演算子 and によって結合されているので、b&gt;a
を評価する必要はなく、この式に偽になります。</P>

<H5>○連結演算子</H5>

<P>２つの文字列を連結する演算子は、Lua では2つのピリオド( ..) で
表されます。連結演算子は２つの文字列を連結した文字列を返します。</P>

<PRE>     a = "Language" 
     b = "Lua" 
     c = a .. " " ..  b</PRE>

<P>この例では a の値に１文字空白が続き、b
の値がつながったもの、つまり "Language Lua" という文字列が変数 c
に代入されます。</P>

<H5>調整</H5>

<P>Luaでは自動的に型の変換が行われることがあります。文字列に算術演算子が使用されていて、その文字列が数値の場合、数値型への変換がされて演算されますが、変換できなければ、実行時エラーとなります。
</P>

<PRE>     b = "53" 
     c = 2 + b　　</PRE>

<P>この例では文字列 "53" は演算の前に数値に変換され、 c には 55 が
代入されます(変数 b は文字列型の値を持ったままです)。
他方で、文字列が必要な文脈で数値を使った場合には(連結演算子など)、
数値は対応する文字列に変換されます。数値が完全なものであれば、小数や指数は点なしの文字列になります。
数値が分数を含む場合には、小数や指数を含むことがあります(脚注３)。
例えば、</P>

<PRE>     print("result:  " .. 23)</PRE>

<P>は次のように出力されます。</P>

<PRE>     result:  23.　　</PRE>

<P>tonumber
というLua言語の標準関数は、可能な場合は文字列を数値型に変換します。数値を文字列に変換するには、
必要に応じて tostring 関数を使うことができます(9参照、 sprintf で
%.16g
の書式で変換します)。複数の演算子が使われている場合は優先順位があり、次の順に演算されます。また括弧を用いて演算順序を変えることができます。　
</P>

<PRE>     ^
     not   - (単項) 
     *     / 
     +     -
     ..
     &lt;     &gt;    &lt;=    ~=    == 
     and   or　　</PRE>

<H4>6. 流れの制御と局所変数</H4>

<P>Lua
にはプログラム言語として一般的な処理制御の機能があり、一群の命令をまとめたり、さらに何回も実行したりすることができます。また
Lua
では、宣言されたブロック中のみで有効の局所変数の宣言をすることもできます。
</P>

<H5>条件文<I> ( if )</I></H5>

<P>Lua の基本的な条件文は <I>if</I> です。 <I>if</I>
文の形式は次のようになります。</P>

<PRE><STRONG>    if</STRONG>  <I>exp</I> <STRONG>then</STRONG> 
　       <I>ブロック 
     </I><STRONG>end</STRONG>　　</PRE>

<P>または、</P>

<PRE><STRONG>     if</STRONG> <I>exp</I><STRONG> then</STRONG> 
       <I>ブロック1</I> 
      <B><STRONG>else</STRONG></B><STRONG> </STRONG><I>
        ブロック2</I> 
      <STRONG>end</STRONG>　　</PRE>

<P>または、</P>

<PRE><STRONG>     if</STRONG> <I>exp1</I>  <STRONG>then </STRONG><I>
        ブロック１</I> 
      <STRONG>elseif</STRONG> <I>exp2</I> <STRONG>then 
       </STRONG><I>ブロック2</I><STRONG>  
       </STRONG>... 
      <STRONG>elseif </STRONG><I>exp N </I><STRONG>then</STRONG><I> 
        ブロックN</I> 
      <B><STRONG>else</STRONG></B><STRONG> 
       </STRONG><I>ブロックN + 1 
      </I><B>end</B> </PRE>

<P>はじめの形式では、式 <I>exp</I> が nil
でない値の場合に<I>ブロック</I>が実行されま す。２番目の形式では、式
<I> exp</I> が nil の場合に<I>ブロック 2</I> が実行され、
そうでなければ<I>ブロック 1</I>
が実行されます。３番目の形式では、多くの条件にもとづいて<I>
if-then-elseif-then- ... -else-end
</I>で条件判断する列を示しました。上記の例では、式 <I> exp1</I>
が真ならば( nil で無いならば)<I>ブロック 1 </I>が実行 され、式
<I>exp2 </I> が真ならば<I> ブロック 2</I>
が実行され、...、全ての式が偽ならば ( nil と等しいならば)
<I>ブロックN+1</I> が実行されます。</P>

<H5>最初に条件式がある繰り返し<I> (while)</I></H5>

<P>Lua には繰り返しを記述するのに２種類の命令があります。 <I>while
</I>と <I>repeat</I> です。 <I> while
</I>では繰り返しの中身を実行するかどうかの判断が先頭でなされます。一般的な形式は次のようになります。
</P>

<PRE>     <B>while</B> <I>expr</I> <B>do 
       </B><I>ブロック 
     </I><B>end</B>　　</PRE>

<P>式 <I>expr </I>が真である間( nil
でない間)、<I>ブロック</I>内の命令が実行 されます。</P>

<P>例として、変数 n の階乗を計算する次のプログラムを示します。</P>

<PRE>     f =  1              --- <I>1 の階乗</I> 
     i =  n              --- <I>繰り返しを制御する変数</I> 
     while i &gt; 0  do 
      f = f * i 
      i = i - 1 
     end　　</PRE>

<P>繰り返しを実行し終えた後には、 f は n の階乗の値を持ち、 i は 0
になります(繰り返しの終了条件)。</P>

<H5>最後に条件式がある繰り返し<I> (repeat)</I></H5>

<P>繰り返しの中身を実行するかどうかの判断を最後に行うのが
<I>repeat</I> て す。一般的な形式は次のようになります。</P>

<PRE>     <B>repeat</B> 
      <I>ブロック</I> 
     <B>until</B> <I>expr</I></PRE>

<P>repeat では、ブロック内の命令は最低でも１回実行されます
(繰り返しを実行するかどうかの判断は繰り返しの最後でしか行われません)。また式
expr が真である間、繰り返されます。
上記と同じ階乗の計算を行うプログラムは次のようになります。</P>

<PRE>     f =  1              --- <I>1 の階乗</I>
     i =  1              --- <I>繰り返しの制御変数</I> 
     repeat 
　    f = f * i  
      i = i + 1 
     until i &gt; n　　　　</PRE>

<H5>局所変数の宣言</H5>

<P>Lua では変数が局所的であることを宣言して使用します。
この局所変数の宣言はブロック内の系列の任意の位置に書くことができ、宣言されたブロックが終わると変数も無効になります。
大域変数と同じ名前の局所変数を宣言すると、一時的に大域変数を隠します
(局所変数が宣言されたブロック内で)。
プログラム中にその変数名が現れた場合には、局所変数として扱われます。局所変数の宣言時の初期化は次のような構文になります。
例として以下のプログラムを示します。</P>

<PRE>     a =  2                --- <I>大域変数に2を代入 </I>
     if a &gt; 0  then 
      local  b = a         --- a <I>の値(2)を初期値として局所変数 b  を宣言 </I>
      a = a + 1            --- <I>大域変数 </I>a<I> に 1  を加える </I>
      local  a = b         --- b<I> の値を初期値として局所変数 </I>a  <I>を宣言</I>
      print(a)             ---<I> 局所変数 </I>a  <I>の値(2)を表示 </I>
     end                   --- <I>局所変数 </I>a, b<I> の有効範囲はここまで 
　</I>
     print(a)              --- <I> 大域変数</I> a<I> の値(3)を表示　　</I>　　</PRE>

<P>１つの命令で複数の局所変数を宣言して初期化することもできます。
</P>

<PRE>     local  a, b, c  =  2,  5+6,  -3　　　　</PRE>

<P>この例では、 a は 2 を初期値とし、 b は 11 を、 c は -3
をそれぞれ初期値としています。初期化されない局所変数の値は nil とな
ります。</P>

<H4>7. 関数</H4>

<P>Lua
では関数はファーストクラスの型として扱われます。つまり、関数は変数に代入したり、他の関数に引数として渡したり、戻り値として返したりするこ
とができます。関数を定義する時には、関数の名前を持つ大域変数に関数の機能を実現するプ
ログラムを代入します。Lua
の関数は大域環境中の任意の場所で定義できます。関数の定義の一般的な形式は次のようになります。
</P>

<PRE>     <B>function</B> <I>name</I> ([ <I>引数のリスト</I> ]) 
      <I>命令のブロック</I> 
     <B>end</B>
   </PRE>

<P>ここで <I>name</I>
は関数が代入される大域変数の名前です。引数のリストは関数内の局所変数と同様に扱われ、関数呼び出しの時の引数で初期化されます。
関数呼び出しの一般的な形式は次のようになります。</P>

<PRE><I>     name</I> ([ <I>引数のリスト</I>  ]) </PRE>

<P>関数名の後に括弧で囲まれた０個以上の引数のリストを続けて書きます。
<I>name</I>
が関数を値として持たない場合(関数型の値では無い場合)には実行時エラーになります(タグ関数参照)。引数が指定された場合には、
まず引数は関数呼び出しの前に評価されます。次に関数定義に指定された仮引数と、関数呼び出しに指定された実引数との間で対応が取られます
(この時に多重代入と同様な調整が行われて対応が決まります)。 Lua
では引数は値渡し(by
value)で渡されます。したがって、関数が呼び出された時点での実引数の値が、関数の仮引数の値にコピーされて関数内の局所変
数になります。関数の呼び出し元では、引数に指定した変数の値は呼び出し時のままで変わりません。
Lua の関数は 0個、1個、またはそれ以上の値を return
命令によって返すことができます。よって、関数呼び出しの時に変数への参照を引数として
渡す必要がありません。関数の実行中に return 命令が現れると、関数
の実行は終了して関数が呼び出された位置の次に制御が戻ります。 return
命令の後には０個以上の式のリストを書くことができます。一般的
の形式は次のようになります。</P>

<PRE>     <B>return</B> [ <I>式のリスト</I> ] </PRE>

<P>構文規則上、 return 命令はブロックの最後でなければなりません。
このことにより、 return
命令の後に置かれて決して実行されない隠れた命令を防ぐことができます。
return 文がブロックの最後でない場合には、文法エラーになります。
関数の戻り値は、関数呼び出しの時に書かれた変数リストに合わせて調整され
ます。例として、座標 (x, y) を更新する次の関数を示します。</P>

<PRE>     function translate  (x, y, dx, dy) 
      return  x+dx,  y+dy 
     end </PRE>

<P>次のように関数呼び出しが行われたとすると、</P>

<PRE>     a,b = translate(20, 30, 1, 2) 　</PRE>

<P>a には 21 (=20+1) が代入され、 b には 32 (=30+2) が代入されます。
次のような関数呼び出しの場合には、</P>

<PRE>     a = translate(20, 30, 1,  2） </PRE>

<P>関数の(２つ目の)戻り値は捨てられ、21
を受け取ります。次のような呼び出 しの場合には、</P>

<PRE>     a, b, c = translate(20, 30, 1, 2)  </PRE>

<P>a には 21 が代入され、 b には 32 が代入され、 c には nil
が代入されます。
複数の値を返す関数呼び出しは値のリストと同一に扱われるわけではありませ
ん。多重代入で調整が行われる時には、１つ目の戻り値だけが考慮されます。例として、少しに異なる２つの例を挙げます。はじめに、次の関数呼び出しの場合には、
</P>

<PRE>     a, b, c = 10, translate(20, 30, 1, 2)   </PRE>

<P>a には 10 が代入され、 b には 21 が代入され、 c には 32
が代入されます。このように関数呼び出しがリストの最後の場合には、関数呼び出しが１つずら
されます。しかし、次の呼び出しでは、</P>

<PRE>     a, b, c = translate(20, 30, 1, 2),  10   </PRE>

<P>驚くかもしれませんが、関数が返す値の個数によらず１つ目の返り値だけが
扱われ(この場合21)、もう１つの返り値の 32 は捨てられます。よって、 a
には 21 が代入され、b には 10 が代入され、cにはnilが代入されます。
Lua では可変個の引数を受け取る関数を定義することができ、これは関数
定義の引数リストの最後にピリオドを３つ ( ...)
つけることで表せます。この形式の関数では実引数と仮引数の対応づけだけで調整は行われません。引数リストに指定された数以上の実引数は、
arg という名前の暗黙の仮
引数に対応づけられます。argは常にテーブルとして初期化され、
フィールド n は余分な引数の数、フィールド1, 2 ... に順に実引数
の値が対応づけられます。では例として、２つの異なる関数定義をします。
</P>

<PRE>     function  f(a, b) end 
     function g(a, b, ...)  end </PRE>

<P>これらの関数呼び出しでは、実引数と仮引数との間で次のような対応づけが行なわれています。
</P>

<PRE>     実引数           仮引数 
     f(3)             a=3,  b=nil 
     f(3,  4)         a=3,  b=4 
     f(3, 4, 5)       a=3,  b=4 
　
     g(3)             a=3,  b=nil, arg={ n=0 } 
     g(3,  4)         a=3,  b=4, arg={ n=0  } 
     g(3, 4, 5, 8)    a=3,  b=4, arg={ 5,8; n=2  }   </PRE>

<H4>8. テーブル型と連想配列</H4>

<P>Lua のテーブルは連想配列であり、数値や文字列などの nil を除く任
意の型の値をインデクスとすることができます。テーブルのこの柔軟性は、
Lua 中のオブジェクトの記述の基礎になっています。</P>

<H5>テーブルの作成</H5>

<P>テーブルは使う前に明示的に作成する必要があり、 {
}で初期化を行います。次は空のテーブルを作成し、t
という変数に代入する例です。</P>

<PRE>     t = {  }   </PRE>

<P>これにより、変数 t はテーブル型の値を持ちます。
代入の例は次のようになります。</P>

<PRE>     t[1] = 13 
　   t[45] = 56 </PRE>

<P>テーブルのインデクスの値に上限はなく、テーブルの次元は必要に応じ
て自動的に変更されます。また、次のように書くこともできます。</P>

<PRE>     t["name"] = t[1] + 2 </PRE>

<P>name という文字列のインデクスに対応するテーブル中の値として、
インデクス 1に対応する値(ここでは 13)に 2
を加えた値を代入します。よっ てインデクス"name" に対応する値は 15
になります。 また以下のように書くこともできます。</P>

<PRE>     t[t] =  5</PRE>

<P>これは t というテーブル型のインデクスに対応する値として 5 を代入し
ています。テーブル t はインデクスとして有効な値です
(一見混乱しているように見えますが、やっていることは間違っていません)。
また文字列をインデクスにするときには、ピリオドを使った記法を用いること
ができます。例えば、</P>

<PRE>     t["version"]=  4 </PRE>

<P>これは以下と等価です。</P>

<PRE>     t.version = 4   </PRE>

<P>この記法の方が分かりやすいので、使うことをおすすめします。
ただし、文字列がスペースを含むときはピリオドを使った表記を用いることはできません。例：
</P>

<PRE>     t["Rio De  Janeiro "] = 1994 </PRE>

<P>数値と同様に、任意の型の値をテーブルに代入することができます。
次に示すのは、テーブルt への正しい代入の例です。</P>

<PRE>     t[10] = "example" 
     t[2.34] = 12 
     t.tabela, t[0] = 3, 12 
     t[-234] = 0 
     a = "Lua" 
     t[a] = 5  </PRE>

<P>最後の例は注意深く見る必要があります。 a は "Lua" という値を
持つ変数と考えると、これは Lua というインデクスに対応する値として5
を代入していることになります。 しかし、t.a はt["a"] と
等価ですが、t[a] とは異なります。 ここでは t[a] と t.Lua
が等価にになります。
インデクスに対応する値を一度も与えられていない(初期化されていない)テー
ブル中の値は nil
になります。したがって上の例の代入だけを行ったとすると、</P>

<PRE>     print(t[999) </PRE>

<P>999
というインデクスに対応する値は初期化されていないため、この命令は nil
を出力します。
テーブル中に他のテーブルを代入することもできるので、多次元配列が実現で
きます。例えば、次のようになります。</P>

<PRE>     m = { } 
     m[1]  = { } 
     m[2]  = { } 
     m[1][1] =  1.0 
     m[2][1] =  0.0 </PRE>

<P>また次のように書くこともできます。</P>

<PRE>     s = { } 
     s.dist = { } 
     s.dist.name =  "Language Lua" 
     s.dist.version =  4 </PRE>

<H5>値を指定したテーブルの初期化</H5>

<P>Lua ではテーブルの作成時に初期化することができます。
テーブルの初期化は次のように行うことができます。</P>

<PRE>     {<I> 式1, 式2, ...., 式N </I> } </PRE>

<P>このようにテーブルを作成する { } の間に式のリストを書きま
す。リストの要素はそれぞれ評価され、１番目の値はインデクス 1
に対応づけられ、２番目の値はインデクス 2 に、というぐあいになります。
したがって次の例は、</P>

<PRE>     t =  {23, 45, -7, "Lua", 6+4} </PRE>

<P>以下と等価です。</P>

<PRE>     t = { } 
     t[1] =  23 
     t[2] =  45 
     t[3] =  -7 
     t[4] =  "Lua" 
     t[5] =  6+4 </PRE>

<P>初期化を行った後でも、テーブルに他の値を代入することはできます。
テーブルにはいつでも nil
以外の任意のインデクスに対応して任意の値を代入することができます。例えば初期化の後に、次のような命令を実行す
ることができます。</P>

<P>t[67] = 0 t["Lua"] = "example"</P>

<H5>フィールドを指定したテーブルの初期化</H5>

<P>Lua ではフィールドを指定してテーブルを初期化することもできます
(訳注: インデクス i に対応する値を、テーブルのフィールド i
とも呼びます)。　</P>

<PRE>一般的な形式は次のようになります。 
　
     { [ <I>式A</I> ] = <I>式1</I>, [ <I>式B</I> ] = <I>式2</I>...  } </PRE>

<P>初期化の際に、インデクスと値の対であるフィールドを指定することができる。テーブルのインデクスが文字列の場合は、次のように単純化することができる。
</P>

<PRE>     <I>string1 </I>=<I> expr1</I>　</PRE>

<P>よって次の例は、</P>

<PRE>     t = { name = "Language Lua  ", [1]= 3.0, [f(x)] = g(y) } </PRE>

<P>以下と等価である。</P>

<PRE>     t = { } 
     t.name = " Language Lua "  
     t[1] = 3.0 
     t.[f(x)] = g(y) </PRE>

<P>同様に、テーブルにはいつでも nil 以外の任意のインデクスに対応し
て任意の値を代入することができます。例えば初期化の後に、次のようにすることができます。
</P>

<PRE>       t["Lua"]="  example " </PRE>

<H5>両方の形式を混在させた初期化</H5>

<P>これまでの２つの初期化の形式を組み合わせて使うことができます。
一般的な形式は次のようになります。</P>

<PRE>     <I>table</I> = { <I>式のリスト </I><B>;</B> <I>フィールドのリスト</I>  } </PRE>

<P>セミコロン<B> ；</B>
で区切られた前半に、連続した数値インデクスで初期化
される式のリストを書き、後半にフィールドのリストを書きます。次の例は、
</P>

<PRE>     t = { nome =  "Linguagem Lua", [1] = 3.0, [f(x)] = g(y) } 
　　 t = { 23,45,-7;
          nome="Linguagem  Lua", 
          versao=3.0, 
　         [4]=80 
     } </PRE>

<P>以下と等価です。</P>

<PRE>     t = {  } 
     t[1] = 23 
     t[2] = 45 
     t[3] = -7 
     t.nome = "Linguagem  Lua" 
     t.versao = 3.0 
     t[4] =  80 </PRE>

<P>Lua
が生成するエラーは以下のように扱われて、まとめられてプログラマに提
示されます。 コンパイル中や実行時にエラーが起こると、エラー処理関数
_ERRORMESSAGE が実行され、Lua を実行する関数 (lua_dofile,
lua_dostring, tolua_dobuffer, lua_callfunction)
が終了され、エラーの状況が返されます。 Lua
はエラー処理関数に対し、エラーの説明が書かれた文字列を引数として与
えます。初期時のエラー関数は単にその文字列を標準出力に出力します。
Lua
の標準入出力ライブラリは関数呼び出しのスタックの履歴等の情報を表示
するため、エラー処理関数を再定義しています。Lua version 4
からは、関数呼び出しのスタックの履歴等の情報が得られるようになりました。
</P>

<H4>10.定義済みの関数</H4>

<P>Luaでは常に利用できる関数が、プログラミングに有用な部品として用意されています。これらの関数は実行環境が変わっても有効です。
</P>

<H5>dofile(<I>filename</I>)　</H5>

<PRE><I>filename</I>  　実行するファイル名 </PRE>

<P>指定されたファイルをLua言語のプログラムとして実行します。エラーで実行できなかった場合は
nil
が返されます。正常終了した場合はプログラムの戻り値をそのまま返しますが、プログラムの戻り値が
nil の時には、nil でない何らかの値になります。</P>

<P> (例)</P>

<PRE>     if not dofile("bib.lua") then
         print("It is not possible to open the library of functions") 
     end　</PRE>

<H5>dostring( <I>string</I> [, <I>name</I> ] )</H5>

<P>文字列をLua言語のプログラムとして実行し、その戻り値を返します。実行が失敗した場合はnilとなり、成功ししてnilを返している場合は、nilでない何らかの値になります。
(例) botao1,botao2,...という名前のテーブルの内容を集約する。</P>

<PRE>     i  = 1; botao = { } 
     b  = dostring("return botao"..i ) 
     while b do 
        botao[i] = b 
        i = i + 1 
        b = dostring("return  botao"..i) 
     end </PRE>

<H5>next(<I> table</I>, <I>index </I>)</H5>

<P>テーブルとそのインデクスを指定して、次の要素のインデクスと値を返します。indexにnilを指定すると、一番最初の要素のインデクスと値が得られます。これを使ってテーブルのすべての要素を列挙することができます。インデクスは数値の他に、文字列など他のデータ型を使うこともできます。戻り値は、インデクスと値の2つで、次の要素がなくなるとnilになります。Lua言語では、文字列のインデクスを使うときも宣言などは必要ありません。指定されたインデクスが存在しないときにはその値はnilという意味になりますが、next()では存在するものだけを順に得ることになります。要素の順番は、Luaによって管理されていて、作成した順ではありません。
</P>

<P> (例) テーブルtの内容をすべてプリントするには次のようにします。
</P>

<PRE>     field,value = next(t, nil)     --<I>テーブルの最初の要素</I> 
     while field do                 --<I>存在するまで</I> 
       print(field, "=", value)     --<I>内容を出力</I> 
       field,value = next(t, field) --<I>次の要素</I> 
     end</PRE>

<H5>nextvar(<I> name</I> )</H5>

<P>大域変数をすべて列挙するのに使います。１つのパラメータ、つまりnameで指定した大域変数の次の大域変数を得ます。nilを指定すると、一番始めの大域変数が得られます。戻り値は、変数の名前とその値の２つになります。
</P>

<P>（例） 大域変数をすべて列挙するには次のようにします。</P>

<PRE>     name,value = nextvar(nil)       --<I>先頭にある大域変数</I> 
     while name do                   --<I>nameが存在すれば</I> 
      print(name, "=", value)        --<I>その内容を表示</I> 
      name,value = nextvar(name)     --<I>次の大域変数</I> 
     end</PRE>

<H5>type(<I> value</I> )</H5>

<P>引数に指定された対象の型を文字列で返します。戻り値は、"nil",
"number", "string", "table", "function", "userdata"
のどれかになります。</P>

<P> （例）</P>

<PRE>     t =  { } 
     print(type(2.4),type("Alo"),type(t),type(t[1]),type(print) </PRE>

<P>（結果）</P>

<PRE>     number 
     string 
     table 
     nil 
     function</PRE>

<H5>tonumber(<I> e</I> [<I>,base</I>] )</H5>

<P>文字列型になっている数字を数値データに変換します。変換できなかった時はnilを返します。１０進数以外の時は、２番目のパラメータに２～３２の数値を指定します。
</P>

<P> （例）</P>

<PRE>     print(tonumber("34.56 "), tonumber("3.2 X"), tonumber(2)) </PRE>

<P>（結果）</P>

<PRE>     34.56 
     nil 
     2 </PRE>

<H5>tostring( <I>e</I> )</H5>

<P>数値データを文字列データに変換します。 </P>

<P>（例）</P>

<PRE>     print(tostring(3.2), tostring({10,20,30}),tostring(print))</PRE>

<P>（結果）</P>

<PRE>     3.2 
     table: 0x324a43 
     function: 0x63ed21 </PRE>

<H5>print( <I>expr1, expr2, ...</I> )</H5>

<P>与えられたデータを標準出力に出力します。出力の書式を整えるにはformat(
)関数を使います。 </P>

<P> （例）</P>

<PRE>     print( 2*3+2 ) 
     print( "valor = ", valor ) </PRE>

<H5>error( <I>msg</I> )</H5>

<P>実行時エラーを生成し、与えられた文字列を標準出力に出力し、実行を中断します。
</P>

<H5> call(<I> func</I>,<I> arg </I>[,<I>retmode</I>] )</H5>

<P> 与えられた関数を、２番目の引数で実行します<I>。arg
</I>はテーブルで、数値のインデクスの順に引数として利用されます。引数の必要ないときには空のテーブルを与えます。３番目のパラメータに"pack"を与えると、関数の戻り値はテーブルに入れられます。
</P>

<PRE>     a = call( sin, {5} )                a = <I>0.871557</I> 
     a = call( max, {1,4,5;n=2})           a = <I>4</I> 
     t = { x=1  } 
     a = call( next,{t,nil;n=2},"pack" )   a=<I>{"x",1;n=2} </I></PRE>

<H5>assert( <I>value</I> [<I>,message</I>] )<FONT SIZE="-2"> </FONT>
</H5>

<P>引数で与えられたデータがnilならばエラーになり、２番目のパラメータに与えた文字列をプリントします。
</P>

<P>（例）</P>

<PRE>     assert( readfrom(FILE),"cannot open" .. FILE )</PRE>

<H4>11. ライブラリ関数</H4>

<P>Luaでは、数学、文字列、ファイル入出力の３つの基本ライブラリ関数が用意されています。
</P>

<H5>文字列処理ライブラリ</H5>

<P>文字キャラクタの列による文字列を扱う汎用の関数として、文字列の長さを調べたり、部分文字列をとったりする関数が使えます。
</P>

<H5>strfind( <I>str, pattern</I> [,<I> init</I> [, <I>plain</I> ]] )
</H5>

<P>文字列strの中に、patternで指定した文字列を探し、初めの場所と終わりの場所の２つの数値が戻り値になります。initで検索を始める最初の場所を指定できます。また、plainでnil以外だった場合は、パターンマッチングの機能を使わずに単純な文字列比較を行います。文字列が見つからなかった場合はnilが戻り値となります。パターンマッチにキャプチャを使った場合は、キャプチャに対応する文字列が戻り値に追加されます。
</P>

<P>（例）</P>

<PRE>     i, f = strfind("Linguagem Lua 3.0", "Lua")
     print( i, f )</PRE>

<P>（結果）</P>

<PRE>     11 13,</PRE>

<P>（例）</P>

<PRE>     data = "13/4/1997"
     i, f, day, month, year = strfind(data, "(%d*)/(%d*)/(%d*)")
     print( day,month, year )</PRE>

<P>（結果）</P>

<PRE>     13, 4, 1997.</PRE>

<H5>文字パターン</H5>

<P>文字の種類を表現するために、以下の記述が用いられます。</P>

<PRE>     x                  (x が ^$()%.[]*+-? のどの文字でもない場合) 文字 x そのものを表します。
     %x　               ｘはアルファベットや数字以外の記号で、その記号自体を表します。特殊文字を表すのに使います。
     .                  すべての文字
     %a                 アルファベット文字
     %A                 アルファベット文字以外
     %d                 数値（10進数）
     %D                 数値以外
     %l                 アルファベット小文字
     %L                 アルファベット小文字以外
     %s                 空白文字（スペース、タブ、quebras de linha)
     %S                 空白文字以外
     %u                 アルファベット大文字
     %U                 アルファベット大文字以外
     %w                 文字と数字
     %W                 文字と数字以外
     [文字パターン列]   指定した文字のうちのどれか
     [^文字パターン列]  指定した文字のどれでもない</PRE>

<P>パターン要素は、次のいずれかです。</P>

<P>・文字パターン</P>

<P>・文字パターンの後に * をつけたものは、その文字の 0
回以上の繰り返しを表します。マッチする範囲ができるだけ長い文字列になるようにします。
</P>

<P>・文字パターンの後に - をつけたものは、その文字の 0
回以上の繰り返しですが、 * とは異なり、一致する範囲がで
きるだけ短い文字列になるようにします。</P>

<P>・文字パターンの後に + をつけたものは、その文字の 1
回以上の繰り返しを表します。一致する範囲ができるだけ長い文字列になるようにします。
</P>

<P>・文字パターンの後に ? をつけたものは、その文字の 1 回または0
回の出現を表します。</P>

<P>・% n　ここで n は 1 から 9 までの数値で、n
番目のキャプチャした部分文字列を表します。</P>

<P>・%b xy　ここで、 x と y は異なる文字で、 x で始まり y
で終わる文字列を表します。例えば、 %b()
は括弧の対応が正しく取れた文字列に一致します。</P>

<P>文字パターンの系列でひとつのパターンを表現できます。パターン先頭の
^ は対象文字列の先頭を意味します。パターン最後の $ は対象文字列の
最後を意味します。パターン中の他の位置に置かれた場合は、^ や $
は特別な意味を持たず、それ自身を表します。</P>

<P>パターン中には括弧で囲まれたパターンが含まれてい留場合は、キャプチャと呼ばれます。マッチングが起こった場合には、キャプチャの部分にマッチした文字列は保存され、後で用いることができます。キャプチャは左括弧に対応する番号がつけられます。
</P>

<P>例えば、"(a*(.)%w(%s *))"では、a*(.)%w(%s
*)に合致する部分文字が第１番目のキャプチャになり、２番目に(.)に合致した一つの文字、%s
*が３番目になります。</P>

<P>（例）</P>

<PRE>     function name (arg1,arg2)
     (function %s*(%a+)(%b()))　
　</PRE>

<P>によって、Lua言語の関数定義は関数の名前
(%a+)と、そのパラメータリスト(%b()をキャプチャとして得ています。</P>

<H5>strlen(<I> str</I> )</H5>

<P>文字列<I>str</I>の長さを戻り値として返します。</P>

<P>（例）</P>

<PRE>     print(strlen("Linguagem Lua"))</PRE>

<P>（結果）</P>

<PRE>     13.</PRE>

<H5>strsub( <I>str</I>,<I> I</I> [,<I> j</I> ] )</H5>

<P>文字列<I>str</I>のｌ番目から<I>ｊ</I>番目までの文字で新たに文字列データを作って返します。<I>j
</I>がない場合は最後の文字までとなります。文字列の最後を
－１として数えて、<I>ｊ</I>に負の値を指定することもできます。例えば、strsub(str,
1, j) の場合は<I>ｊ</I>番目の文字までを返し、strsub(str, i)
はｉ番目から後の文字を返します。</P>

<P>（例）</P>

<PRE>     a = "Linguagem Lua"
     print(strsub(a, 11))</PRE>

<P>（結果）</P>

<PRE>     Lua.</PRE>

<H5>strlower(<I> str </I>)</H5>

<P>文字列<I>str</I>を小文字にします。</P>

<P>（例）</P>

<PRE>     print(strlower("Language Lua"))</PRE>

<P>（結果）</P>

<PRE>     language lua</PRE>

<H5>strupper( str )</H5>

<P>文字列<I>str</I>を大文字にします。</P>

<P>（例）</P>

<PRE>     print(strupper("Linguagem Lua"))</PRE>

<P>（結果）</P>

<PRE>     LANGUAGE LUA.</PRE>

<H5>strrep( <I>str</I>,<I> n</I> )</H5>

<P>文字列<I>str</I>をn回繰り返した文字列を作ります。</P>

<P>（例）</P>

<PRE>     print(strrep( "0123456789", 2 ))</PRE>

<P>（結果）</P>

<PRE>     01234567890123456789</PRE>

<H5>ascii(<I> str</I> [,<I> I</I>] )</H5>

<P>文字列<I>str</I>の<I>l</I>番目の文字のASCIIコードを返します。</P>

<P>（例）</P>

<PRE>     print(ascii("abc",2))</PRE>

<P>（結果）</P>

<PRE>     42.</PRE>

<H5>format( <I>formatstring</I>, <I>exp1</I>,<I> exp2</I>, ... )
</H5>

<P>文字列formatstringに従ってそれ以降のexp1,exp2,の値を指定した書式で文字列に変換します。書式は%に続けて表示の型を示すアルファベット文字をつけた形式でC言語におけるprintfとほぼ同じです。変換した文字列を戻り値として返します。
</P>

<P>（例）</P>

<PRE>     name = "Car"
     id = 123
     cmd = format( "insert into table (name, id)
                    values (%s , %d)" , name, id )</PRE>

<P>SQLの挿入コマンド(insert)となる文字列を、テーブルのidと名前を使って作っている例です。
</P>

<PRE>     print( format( "%c", 65 ) )</PRE>

<P>このようにして、データの文字を表すANSI(American NationalStandard
Code for Information Interchange) のコード変換が可能です。</P>

<P>（例）</P>

<PRE>     a = 123.456
     print ( format( "%+010.2f", a ) )</PRE>

<P>（結果）</P>

<PRE>     +000123.46.
　
     %s
     %q      では
     %s      文字列
     %q      文字列を引用符でかこむ
     %c      文字
     %d      １０進整数
     %i      %dと同じ
     %u      inteiro sem sinal
     %o      ８進整数
     %x      １６進整数(abcdef)
     %X      １６進整数(ABCDEF)
     %f      実数 [-]ddd.ddd
     %e      実数 [-]d.ddd e[+/-]ddd
     %g      実数 %fまたは %e
     %E      実数 %eと同じだが大文字のEを使う
     %%      %文字そのもの</PRE>

<P>書式制御のために、占める文字列の最小サイズを修飾子として%のあとに指定します。(former:
%10d)負の値は、左づめを指定します。＋を付けると数値の前に＋か－を付けます。さらにピリオドに続けて、小数点以下の桁数を指定できます。(former:
%.2f). 0を指定すると数値の左に０を追加します。</P>

<H5>gsub(<I> str</I>, <I>pattern</I>,<I> repl</I> [,<I> n</I> ] )
</H5>

<P>文字列<I>str</I>からパターン文字列<I>pattern</I>を探し、文字列<I>repl</I>で置換します。replに関数を指定することもでき、関数を実行した結果で置換します。パターンはstrfindの時と同じで、パターンが見つかるごとに置換が行われますが、４番目に指定した<I>ｎ</I>で置換回数の最大を指定できます。パターンがキャプチャを含んでいると、それらは<I>repl</I>文字列中にある%1,%2に展開されます。<I>repl</I>が関数の時は、キャプチャされた文字列が関数のパラメータとして渡されます。戻り値は、置換した文字列と、置換した回数です。
</P>

<P>（例）</P>

<PRE>     print( gsub( "Linguagem Lua 3.0", " ", "+" ) )</PRE>

<P>（結果）</P>

<PRE>     Linguagem+Lua+3.0.</PRE>

<P>（例２）</P>

<PRE>     texto = "    Linguagem       Lua       3.0 "
     print(  gsub( texto,  "  *",  "  " ) )</PRE>

<P>（結果２） 置換は行われないので、</P>

<PRE>     "Linguagem Lua 3.0 ".</PRE>

<P>（例３）キャプチャ機能</P>

<PRE>     lista  = [[
     arq.txt
     texto.txt
     r.txt
     ]]
     print( gsub( lista, "(.*)%.txt\n",  "move %1.txt %1.bak\n"  ))</PRE>

<P>（結果）</P>

<PRE>     move arq.txt arq.bak
     move texto.txt texto.bak
     move r.txt r.bak</PRE>

<H5>数学ライブラリ</H5>

<P>数値データの最大値、最小値を得る関数では、可変個数の引数を使うことができます。
</P>

<PRE>     min( expr1, expr2, ..., <I>exprN</I>)
     max( expr1, expr2, ...,<I> exprN</I>)</PRE>

<P>（例）</P>

<PRE>     print(min(23, 5, 123, 3))
     print(max(23, 5, 123, 3))</PRE>

<P>（結果）</P>

<PRE>     3 123.</PRE>

<P>C
言語で利用されている数学関数ライブラリも利用できます。角度の単位はラジアンではなく度です。
</P>

<PRE>     log(value)         logaritmo de value na base e
     log10(value)       logaritmo de value da base 10
     cos(angle)         cosseno de angle (especificado em graus)
     sin(angle)         seno de angle (especificado em graus)
     tan (angle)        tangente de angle (especificado em graus)
     acos(value)        arco cosseno, em graus, de value
     asin(value)        arco seno, em graus, de value
     atan(value)        arco tangente, em graus, de valuea
     tan2(y,x)          arco tangente, em graus, de y/x
     deg(angle)         converte angle (especificado em radianos) para graus
     rad(angle)         converte angle (especificado em graus) para radianos
     abs(value)         valor absoluto de value
     sqrt(value)        raiz quadrada de value
     ceil(value)        inteiro imediatamente inferior a value
     floor(value)       inteiro imediatamente superior a value
     mod(value,div)     resto da divis黍 inteira de value por div</PRE>

<H5>入出力関数</H5>

<P>オペレーティングシステムにおいて、ファイルあるいは装置からのデータの入出力を行うライブラリです。lua言語では、ファイルハンドルと呼ばれる変数でファイルを指定しますが、デフォルトの入力と出力の２つのファイルハンドルはファイルハンドルを省略することができます。デフォルトのファイルハンドルとして
(_ INPUT)と(_ OUTPUT)の大域変数が使われます。C
言語での標準入出力である stdin、stdout、stderr も、大域変数 _
STDIN、_STDOUT 、_ STDERR　で参照することができます。初期状態では_
INPUT は_STDIN に、 _ OUTPUT は_ STDOUTに設定されています。</P>

<H5>readfrom( <I>filename</I> )</H5>

<P>指定したファイルをデフォルトの読み取り用にオープンし、ファイルハンドルを_INPUTに設定します。filenameを指定しなかった時は、現在のファイルがクローズされてデフォルトの入力ファイルを_STDINに戻します。戻り値としてファイルハンドルが得られます。失敗したときはnilと、エラーメッセージの２つが得られます。
</P>

<P>（例）</P>

<PRE>     readfrom( "c:\\txt\\b.txt" )</PRE>

<H5>writeto( [<I>filename </I>])</H5>

<P>指定したファイルを書き込み用にオープンし、ファイルハンドルを_OUTPUTに設定します。ファイルが存在すればその内容は消去されて新しいファイルになります。成功するとファイルハンドルを戻り値として返します。失敗したときはnilと、エラーメッセージの２つが得られます。filenameを指定しなかった時は、現在のファイルはクローズされてデフォルトの出力を_STDINに戻します
</P>

<P>（例）a.txt
ファイルを新規作成して文字を書く。すでに存在すると、何もしない。</P>

<PRE>     if writeto( "a.txt" ) then
       write( "result is 123" )
       writeto( )
     end</PRE>

<H5>appendto( [<I>filename</I>] )</H5>

<P>指定したファイルを追加書き込みでオープンし、writeto()と同様にします。既存のファイルの内容は消去されません。
</P>

<P>（例）a.txtというフィアルに文字を追記する。ファイルがなければ何もしない。
</P>

<PRE>     if appendto( "a.txt") then
       write( "result is 123" )
       appendto ()
     end</PRE>

<H5>read( <I>[format</I>] )</H5>

<P>現在の入力装置_
INPUTからデータを読み込みます。読み込んだデータを戻り値として返します。失敗した場合は、
nilになります。formatは、次のいずれかの文字列です。</P>

<PRE>     "*l",     １行単位
     "*n",     単語単位
     "*w",     ファイルすべて
     "*n"      数値データ</PRE>

<P>指定のないときは行単位になります。また、数値を指定すると、指定したバイト数の読み込みをします。（訳者注：バージョン3.2まで利用されていたパターンでの読み込みは廃止されました）
</P>

<P>（例）ファイルの数値をすべて読んでテーブルに入れます。</P>

<PRE>     data = { }
     i = 1readfrom( "datas.txt" )
     repeat
        data[i] = read( "*n" )
        i = i + 1
     until data == nil
     readfrom()</PRE>

<H5>write(<I> value1</I>,<I> value2</I>, ...)</H5>

<P>現在の出力装置 (_OUTPUT).に与えられたデータvalue1, value2, ...
を出力します。失敗したときに戻り値はnilとなり、成功するとそれ以外の値となります。print()と違って、データは数値あるいは文字列でなければエラーとなります。
</P>

<P>（例）</P>

<PRE>     write(  "a = ", a  )</PRE>

<H5>remove( <I>filename </I>)</H5>

<P>filenameで指定されたファイルを削除します。失敗したときは戻り値がnilになります。
</P>

<P>（例）</P>

<PRE>     a, error = remove( "c:\doc\arq.txt" )
     if not a then
       print( error )
     end</PRE>

<H5>rename(<I> name1</I>, <I>name2 </I>)</H5>

<P><I>name1</I>のファイル名<I>をname2</I>に変更します。失敗した時の返り値はnilになります。
</P>

<P>（例）</P>

<PRE>     a, error = rename( "arq.txt", "arquivo.txt" )
     if not a then
       print( error )
     end</PRE>

<P>arq.txt を arquivo.txt
に変更します。変更できなければメッセージを出力します。</P>

<H5>tmpname( )</H5>

<P>一時ファイルとして安全に使えるファイル名を返り値として返します。
</P>

<P>（例）作業ファイルに書き込み準備する</P>

<PRE>     filename = tmpname( )
     writeto( filename )</PRE>

<H5>date( [<I>format]</I> )</H5>

<P>現在の日付と時刻を取得して文字列を戻り値として返します。書式は、unixのstrftime()関数で使われているもので、省略するとそのオペレーティングシステムで一般的な形式で出力します。
</P>

<PRE>     %a        省略形の曜日
     %A        完全な曜日
     %b        省略形の月
     %B        月
     %c        一般的な日付と時刻
     %d        日付 01 ～ 31
     %H        時 00 ～ 23
     %I        時間 01 ～ 12
     %j        今年の通算日数 001 ～ 366
     %m        月　01 ～12
     %M        分 00 ～ 59
     %P        午前午後　am/pm
     %S        秒 00 ～ 60
     %U        今年の通算週数　日曜から 00 ～ 53
     %w        今週の日曜からの日数　 0 ～ 6
     %W        今年の通算週数月曜から 00 ～ 53
     %x        一般的な日付表記
     %X        一般的な時間表記
     %y        年の下２桁
     %Y        ４桁の年
     %z        タイムゾーン
     %%        %自体を表す</PRE>

<P>（例）</P>

<PRE>     print( date( "day %d month %B" ) )</PRE>

<P>（結果）</P>

<PRE>     day 14 month August</PRE>

<H5>exit( [<I>code</I>] )</H5>

<P>プログラムの実行を終了して数値codeをオペレーティングシステムにおけるプログラムの終了値とします。codeを指定しないときは１です。この関数は戻り値はありません。
</P>

<P>（例）大域変数termina=programaが設定されていると、プログラムを終了させます。
</P>

<PRE>     if termina_programa then
       exit( )
     end</PRE>

<H5>getenv( <I>varname</I> )</H5>

<P>オペレーティングシステムから与えられる環境変数から、文字列varnameで示されるデータを戻り値として返します。環境変数が存在しないときはnilになります。
</P>

<P>（例）</P>

<PRE>     print( getenv( "REMOTE_HOST" ) )</PRE>

<P>環境変数 REMOTE_HOSTをプリントします。</P>

<H5>execute(<I> command</I> )</H5>

<P>オペレーティングシステムにおいて、文字列 <I>command</I>
を実行コマンドとして実行します。戻り値はコマンドの終了コードで、システムに依存します。
</P>

<P>（例）</P>

<PRE>     execute( "mkdir c:\data" )</PRE>

<P>最後に</P>

<P>Luaの特徴の一つに、産業界と大学の両面で利用されていることがあげられます。PUC-Rioで開発されたプログラムは産業界では数十のプロジェクトに利用され、学術的にも多くの反響を呼び、多数の学位論文や学術論文に掲載されました。
</P>

<P>著作権表示</P>

<P>Copyright (c) 1994-1998 TeCGraf, PUC-Rio. Written by Waldemar
Celes Filho, Roberto Ierusalimschy, Luiz Henrique de Figueiredo. All
rights reserved.</P>

<P>Permission is hereby granted, without written agreement and
without license or royalty fees, to use, copy, modify, and distribute
this software and its documentation for any purpose, subject to the
following conditions:</P>

<P>* The above copyright notice and this permission notice shall
appear in all copies or substantial portions of this software.</P>

<P>* The name "Lua" cannot be used for any modified form of this
software that does not originate from the authors. Nevertheless, the
name "Lua" may and should be used to designate the language
implemented and described in this package, even if embedded in any
other system, as long as its syntax and semantics remain unchanged.
</P>

<P>The authors specifically disclaim any warranties, including, but
not limited to, the implied warranties of merchantability and fitness
for a particular purpose. The software provided hereunder is on an
"as is" basis, and the authors have no obligation to provide
maintenance, support, updates, enhancements, or modifications. In no
event shall TeCGraf, PUC-Rio, or the authors be liable to any party
for direct, indirect, special, incidental, or consequential damages
arising out of the use of this software and its authors be liable to
any party for direct, indirect, special, incidental, or consequential
damages arising out of the use of this software and its
documentation.</P>

<P>[EOF]</P>
</BODY>
</HTML>
